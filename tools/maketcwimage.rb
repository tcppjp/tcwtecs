#!/usr/bin/env ruby

require 'optparse'

require 'RMagick'
include Magick

options = {}
OptionParser.new do |opts|
  opts.banner = "Usage: maketcwimage.rb -i IMAGEFILE -f mono|rgbx32|rgb565 -o OUTPUTFILE -n SYMNAME"

  opts.on("-o OUTPUTFILE", "--output OUTPUTFILE", "The name of output files, without .c or .h") do |output_file|
    options[:output_file] = output_file
  end
  opts.on("-i IMAGEFILE", "--input IMAGEFILE") do |input_file|
    options[:input_file] = input_file
  end
  opts.on("-f FORMAT", "--format FORMAT", "One of mono, rgbx32, and rgb565") do |format_name|
    options[:format] = format_name
  end
  opts.on("-n SYMBOLNAME", "--name SYMBOLNAME") do |symbol_name|
    options[:symbol_name] = symbol_name
  end
  opts.on("-h", "--help", "Prints this help") do
    puts opts
    exit
  end
end.parse!

unless options.has_key?(:output_file)
  puts "Output file (-o/--output) must be specified"
  exit 1
end

unless options.has_key?(:input_file)
  puts "Input file (-i/--input) must be specified"
  exit 1
end

unless options.has_key?(:symbol_name)
  puts "Symbol name (-n/--name) must be specified"
  exit 1
end

unless options.has_key?(:format)
  puts "Output pixel format (-f/--format) must be specified"
  exit 1
end

case options[:format]
when 'mono'
  out_format = :mono
when 'rgb565'
  out_format = :rgb565
when 'rgbx32'
  out_format = :rgbx32
else
  puts "Unrecognized output pixel format: #{options[:format]}"
  exit 1
end

input_image = ImageList.new(options[:input_file])

out_elements = []

width = input_image.columns

input_image.rows.times do |y|
  case out_format
  when :mono
    scanline = input_image.export_pixels(0, y, width, 1, "R")

    # byte padding
    while scanline.length & 7
      scanline << 0
    end

    # covert to output format
    ((width + 7) / 8).times do |byte_offset|
      out_byte = 0
      8.times do |i|
        if scanline[(byte_offset << 3) + i] > 128
          out_byte |= 1 << i
        end
      end
      out_elements << out_byte
    end
  when :rgb565
    scanline = input_image.export_pixels(0, y, width, 1, "RGB")

    width.times do |x|
      out_pixel = scanline[x * 3] >> 3
      out_pixel |= (scanline[x * 3 + 1] >> 2) << 5
      out_pixel |= (scanline[x * 3 + 2] >> 3) << 11
      out_elements << out_pixel
    end
  when :rgbx32
    scanline = input_image.export_pixels(0, y, width, 1, "RGB")

    width.times do |x|
      out_pixel = scanline[x * 3]
      out_pixel |= (scanline[x * 3 + 1]) << 8
      out_pixel |= (scanline[x * 3 + 2]) << 16
      out_elements << out_pixel
    end
  end
end

# generate C source
out_source_name = options[:output_file] + ".c"
out_header_name = options[:output_file] + ".h"
out_name = File.basename(options[:output_file])

num_out_element_digits = case out_format
  when :mono then 2
  when :rgb565 then 4
  when :rgbx32 then 6
end

out_type_name = case out_format
  when :mono then 'uint8_t'
  when :rgb565 then 'uint16_t'
  when :rgbx32 then 'uint32_t'
end

pixel_format_name = case out_format
  when :mono then 'TWPixelFormat1bppMonotone'
  when :rgb565 then 'TWPixelFormat16bppRGB565'
  when :rgbx32 then 'TWPixelFormat32bppRGBX'
end


symbol_name = options[:symbol_name]

elements_per_line = 20 / out_element_width

out_source = "// Do not edit; generated by maketcwimage.rb\n"
out_source << "\#include \"#{out_name}.h\"\n\n"
out_source << "#{out_type_name} #{symbol_name}[] = {\n"

num_out_lines = (out_elements.length + elements_per_line - 1) / elements_per_line

num_out_lines.times do |line|
  out_source << "  "
  out_elements[line * elements_per_line, elements_per_line].each do |element|
    element_str = ("000000" + element.hex)[-num_out_element_digits, num_out_element_digits]
    out_source << "0x#{element_str}, "
  end
  out_source << "\n"
end

out_source << "};\n"

out_header = "// Do not edit; generated by maketcwimage.rb\n"
out_header << "\#pragma once\n\n" # non-standard directive :)
out_header << "\#include \"tecsui/bitmap.h\"\n\n"
out_header << "extern #{out_type_name} #{symbol_name}[#{out_elements.length}];\n"
out_header << "\#define #{symbol_name}_Width #{input_image.columns}\n"
out_header << "\#define #{symbol_name}_Height #{input_image.rows}\n"
out_header << "\#define #{symbol_name}_PixelFormat #{pixel_format_name}\n"

File.open(out_source_name, "w") do |f|
  f.write(out_source)
end

File.open(out_header_name, "w") do |f|
  f.write(out_header)
end
